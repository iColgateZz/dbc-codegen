use embedded_can::{ExtendedId, Frame, Id, StandardId};

#[derive(Debug, Clone)]
pub enum CanError {
    Err1,
    Err2,
    // ...
}

pub trait CanMessage<const LEN: usize>: Sized {
    fn try_from_frame(frame: &impl Frame) -> Result<Self, CanError>;
    fn encode(&self) -> (Id, [u8; LEN]);
}

#[derive(Debug, Clone)]
pub enum Msg {
    EngineData(EngineData),
    OtherData(OtherData),
}

impl Msg {
    fn try_from(frame: &impl Frame) -> Result<Self, CanError> {
        let id = match frame.id() {
            Id::Standard(sid) => sid.as_raw() as u32,
            Id::Extended(eid) => eid.as_raw(),
        };

        let result = match id {
            EngineData::ID => Msg::EngineData(EngineData::try_from_frame(frame)?),
            OtherData::ID => Msg::OtherData(OtherData::try_from_frame(frame)?),
            _ => return Err(CanError::Err1),
        };

        Ok(result)
    }
}

#[derive(Debug, Clone)]
pub struct EngineData {
    pub rpm: f32,
    pub speed: f32,
}

impl EngineData {
    const ID: u32 = 100;
    const LEN: usize = 8;
}

impl CanMessage<{ EngineData::LEN }> for EngineData {
    fn try_from_frame(frame: &impl Frame) -> Result<Self, CanError> {
        let data = frame.data();

        let raw_rpm = u16::from_le_bytes([data[0], data[1]]);
        let raw_speed = u16::from_le_bytes([data[2], data[3]]);

        Ok(Self {
            rpm: raw_rpm as f32 * 0.125,
            speed: raw_speed as f32 * 0.01,
        })
    }

    fn encode(&self) -> (Id, [u8; EngineData::LEN]) {
        let mut data = [0u8; EngineData::LEN];

        let raw_rpm = (self.rpm / 0.125) as u16;
        let raw_speed = (self.speed / 0.01) as u16;

        let rpm_bytes = raw_rpm.to_le_bytes();
        let speed_bytes = raw_speed.to_le_bytes();

        data[0] = rpm_bytes[0];
        data[1] = rpm_bytes[1];
        data[2] = speed_bytes[0];
        data[3] = speed_bytes[1];

        let id = Id::Extended(ExtendedId::new(Self::ID).unwrap());
        (id, data)
    }
}

#[derive(Debug, Clone)]
pub struct OtherData {
    pub something: f32,
}

impl OtherData {
    const ID: u32 = 101;
    const LEN: usize = 8;
}

impl CanMessage<{ OtherData::LEN }> for OtherData {
    fn try_from_frame(frame: &impl Frame) -> Result<Self, CanError> {
        // some logic
        Ok(
            Self {
                something: 5.0
            }
        )
    }

    // other things ...
    fn encode(&self) -> (Id, [u8; Self::LEN]) {
        let data = [0u8; Self::LEN];

        //some data manipulations

        let id = Id::Standard(StandardId::new(Self::ID as u16).unwrap());

        (id, data)
    }
}
